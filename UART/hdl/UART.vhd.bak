-- USB to TTL over UART protocol
-- fixed baudrate 115200
-- clk freq 50MHz
-- unit is wrapped with avalon mm interface with logic similar to the UART qsys component
-- automatic configuration - no parity bit, 

-- Designer : Doron Kopit
-- Version: 0.1


library ieee;
library work;

use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.uart_pkg.all;

ENTITY UART	IS 
GENERIC (
		baudrate	: BAUD := 115200;
		dataBits	: integer range 7 to 9 := 8;
		stopBits : integer range 1 to 2 := 1
);
PORT(
	clk 	:	in		std_logic;
	rstn 	:	in		std_logic;
	-- uart io
	rxd	: in		std_logic;
	txd	: out		std_logic;
	
	-- indication
	dataavailable_n 		: out std_logic;
	readyfordata_n		: out std_logic;
	
	-- avalon-mm:
	avmm_address 		: in	std_logic;
	avmm_read			: in	std_logic;
	avmm_readdata		: out	std_logic_vector(15 downto 0);
	avmm_write			: in	std_logic;
	avmm_writedata		: in	std_logic_vector(15 downto 0);
	avmm_waitrequest	: out	std_logic
);
END UART;

ARCHITECTURE BEHAVE OF UART IS 
signal divisor 				: 	integer;
signal midpoint				:	integer;
signal counter 				: 	unsigned(12 downto 0);
signal bitCount				:	unsigned(3 downto 0);				--	 0111 <=>7, 1000 <=>8, 1001 <=> 9
signal stopBitCount			:	stopbitsType; 								-- '0'<=>1, '1'<=>2
signal databits_local		:	unsigned(3 downto 0);
signal stopBits_local		:	stopbitsType;
signal state, nextState		:	UART_State;
signal txdata, rxdata		:	std_logic_vector(8 downto 0);
signal txShReg, rxShReg		:	std_logic_vector(8 downto 0);
signal txReady, rxReady		:	std_logic;
signal avmm_writedata_sig	:	std_logic_vector(8 downto 0);
BEGIN

divisor <= baudrateDivisor(baudrate);
midpoint <= baudrateMidpoint(baudrate);
databits_local <= translateDataBits(dataBits);
stopBits_local <= translateStopBits(stopBits);
avmm_writedata_sig <= avmm_writedata(8 downto 0);

sync_proc : process (clk, rstn)
begin
	if rstn='0' then
		counter 	<= (others=>'0');
		bitCount <= (others=>'0');
		stopBitCount <= (others=>'0');
		txd <= '1';
		state		<= IDLE;
		
		rxdata <= (others=>'0');	rxShReg <= (others=>'0');	rxready <='0';
		txShReg <= (others=>'0');	
		
		readyfordata_n <= '1';
		dataavailable_n <= '1';
		
	elsif (rising_edge(clk)) then
		-- counter increment
		counter <= counter+1;
		if to_integer(counter)=divisor then
			counter <= (others => '0');
			bitCount <= bitCount + 1;
			stopBitCount <= stopBitCount + 1;
			if bitCount=databits_local then
				bitCount <= (others =>'0');
			end if;
			if stopBitCount=stopBits_local then
				stopBitCount <= (others=>'0');
			end if;
		end if;
		
		state <= nextState;
		
		case state is
			--============ IDLE state ============--
			when IDLE =>
				counter <= (others=>'0');
				bitCount <= (others=>'0');
				stopBitCount <= (others=>'0');
				txd <= '1';
				readyfordata_n <= '0';
			
			--============ Tx_StartBit ============--
			when Tx_StartBit =>
				if to_integer(counter)=midpoint then
					txShReg <= txdata;
				end if;
				bitCount <= (others=>'0');
				stopBitCount <= (others=>'0');
			--============ Tx ============--
			when Tx =>
				txd <= txShReg(to_integer(bitCount));
				readyfordata_n	<= '1';
				stopBitCount <= (others=>'0');	
			--============ Tx_StopBit ============--		
			when Tx_StopBit =>
				txd <= '1';
				txShReg <= (others=>'0');
				
			--============ Rx_StartBit ============--
			when Rx_StartBit =>
				bitCount <= (others => '0');
				rxShReg <= (others => '0');
				rxready <= '0';
				stopBitCount <= (others=>'0');	
				
			--============ Rx ============--
			when Rx =>
				if to_integer(counter)=midpoint then
					rxShReg(to_integer(bitCount)) <= rxd;
				end if;
				stopBitCount <= (others=>'0');	
			--============ Rx_StopBit ============--		
			when Rx_StopBit =>
				if to_integer(counter)=midpoint and rxd='1' then
					rxdata <= rxShReg;
					bitCount <= bitCount + 1;
				elsif to_integer(counter)=divisor and rxd='1' then
					dataavailable_n <= '0';
					rxready <= '1';
				end if;
			
			--============ Others ============--		
			when others =>
				counter <= (others=>'0');
				bitCount <= (others=>'0');
				stopBitCount <= (others=>'0');
		end case;
	end if;
end process sync_proc;

async_proc : process (state, bitCount, counter, txReady, rxd)
begin

case state is 
			--============ IDLE state ============--
			when IDLE =>
					nextState <= IDLE;
					
					if rxd='0' then
						nextState <= Rx_StartBit;
					elsif txReady='1' then
						nextState <= Tx_StartBit;
					end if;
						
			--============ Tx_StartBit ============--
			when Tx_StartBit =>
				nextState <= Tx_StartBit;
				if to_integer(counter)=divisor then
					nextState <= Tx;
				end if;
		
			--============ Tx ============--
			when Tx =>
				nextState <= Tx;
				if to_integer(counter)=divisor and bitCount===databits_local then
					nextState <= Tx_StopBit;
				end if;
			
			--============ Tx_StopBit ============--		
			when Tx_StopBit =>
				nextState <= Tx_StopBit;
				if to_integer(counter)=divisor and stopBitCount=stopBits_local then
					nextState <= IDLE;
				end if;
			
			--============ Rx_StartBit ============--
			when Rx_StartBit =>
				nextState <= Rx_StartBit;
				if to_integer(counter)=divisor then
					nextState <= Rx;
				end if;
			--============ Rx ============--
			when Rx =>
				nextState <= Rx;
				if to_integer(counter)=divisor and bitCount=databits_local then
					nextState <= Rx_StopBit;
				end if;
			--============ Rx_StopBit ============--		
			when Rx_StopBit =>
				nextState <= Rx_StopBit;
				if rxd='1' and to_integer(counter)=divisor and stopBitCount=stopBits_local then
					nextState <= IDLE;
				end if;
			--============ Others ============--		
			when others =>
				nextState <= IDLE;
		end case;
end process async_proc;

avalon_proc: process (clk, rstn)
begin
	if rstn='0' then	
		avmm_readdata <= (others=>'0');
		avmm_waitrequest <='1';
		txReady <= 	'0';
		txdata <= (others=>'0');
	elsif rising_edge(clk) then
		avmm_waitrequest <= '0';
		txReady <= '0';
		if avmm_write='1' and avmm_address='0' then 
			avmm_waitrequest <= '1';
			txdata <= avmm_writedata_sig;
			txReady <= '1';
		elsif avmm_read='1' and rxReady='1' and avmm_address='1' then
			avmm_waitrequest <= '1';
			avmm_readdata(8 downto 0) <= rxdata;
			avmm_readdata(15 downto 9) <= (others=>'1');
		end if;
	end if;

end process avalon_proc;
END BEHAVE;